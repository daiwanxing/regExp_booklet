### 关于正则中的回溯


#### 1. 什么是回溯 ？

在阐述什么是"回溯"之前我们先回顾一下，什么是"贪婪匹配", 贪婪匹配是正则匹配中的一个匹配机制。

看下面一个简单正则代码

```js
/\d{1,3}911/
```

这个正则目的是匹配数字以及拼接的`911`，至少匹配一次至多匹配3次，在贪婪匹配的作用下，总是尽可能的满足最多次的匹配，也就是尽可能的去满足匹配三个连续的数字。

```js
// test
"1911".match(/\d{1,3}911/); // ["1911", 1];
"12911".match(/\d{1,3}911/); // ["12911", 12];
"12011".match(/\d{1,3}911/); // ["120911", 120];
```

贪婪匹配回顾完后，接下来该理解理解什么是回溯了。

回溯和字面意思一致，正则的匹配规则默认是从左往右匹配，当一个匹配是回溯匹配且匹配无法进行下一步时，后退一步再继续进行匹配，直到能够完成整个正则匹配或者匹配结束。

我个人对一个字符串是否为`回溯匹配`的判断主要在于能够满足正则中所有的贪婪匹配的最大匹配就是<strong>没有回溯的匹配</strong>。

例如，上述的正则`/\d{1,3}911/`;

输入用例: 1911; ✅ 

<i>肯定能满足匹配要求，但是会产生回溯匹配，因为没有满足这个正则中的最大贪婪匹配</i>

如果将匹配依次拆解出来就能很好明白

| 正则 | 文本 | 说明
| ------ | ------ | ------ |
| `\d{1,3}911` | `1`911 | `1` 满足`\d{1,3}`中的最小匹配， 由于没有惰性匹配的限制，所以仍不满足最大匹配，继续向右寻找 |
| `\d{1,3}911` | `19`11 | `19` 满足`\d{1,3}`中的2次连续匹配，但仍不满足最大匹配，继续向右寻找 |
| `\d{1,3}911` | `191`1 | `191` 满足`\d{1,3}`中的最大匹配，贪婪匹配圆满完成，接下来开始匹配字符`9`  |
| `\d{1,3}911` | `191`1❌ | 由于`\d{1,3}`拿走了`191`三个字符，最后一个字符`1`不能被正则中的`9`所匹配，接下来贪婪匹配必须得一次次让出自己拿到的，尽可能匹配整个字符串 |
| `\d{1,3}911` | `19`11  | `\d{1,3}`让出最后一个匹配的字符，现在只匹配了`19` |
| `\d{1,3}911` | `19`11❌  | 正则`\d{1,3}`拿掉字符`1`和`9`后，后面的字符`1`还是不能匹配正则中的`9`，贪婪匹配又不得不做出一次让步， 只匹配最小匹配 |
| `\d{1,3}911` | `1`911  | 贪婪匹配已经做出最大让步了`\d{1,3}`现在只匹配`1`，剩余的未匹配的`911`字符串与正则中的`911`匹配成功，至此整个正则匹配结束 |

#### 2. 没有回溯的匹配

```js
const regExp = /ab{1,3}c/;
const inputStr = "abbbc";
```

#### 3. 有回溯的匹配

```js
const regExp = /ab{1,3}c/;

const inputStr = "abbc";
```